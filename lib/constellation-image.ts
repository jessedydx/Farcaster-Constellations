import sharp from 'sharp';
import path from 'path';
import fs from 'fs/promises';
import axios from 'axios';

// Star coordinates based on the provided image structure (Center, Inner 5, Outer 10)
// These are normalized coordinates (0-1) to be independent of image resolution
// We will adjust these based on the actual image aspect ratio later
const STAR_COORDINATES = [
    // Center Star
    { x: 0.5, y: 0.5, size: 0.30 },

    // Inner Ring (5 stars)
    { x: 0.5, y: 0.23, size: 0.16 },
    { x: 0.757, y: 0.417, size: 0.16 },
    { x: 0.659, y: 0.718, size: 0.16 },
    { x: 0.341, y: 0.718, size: 0.16 },
    { x: 0.243, y: 0.417, size: 0.16 },

    // Outer Ring (10 stars)
    { x: 0.5, y: 0.08, size: 0.12 },
    { x: 0.747, y: 0.16, size: 0.12 },
    { x: 0.899, y: 0.37, size: 0.12 },
    { x: 0.899, y: 0.63, size: 0.12 },
    { x: 0.747, y: 0.84, size: 0.12 },
    { x: 0.5, y: 0.92, size: 0.12 },
    { x: 0.253, y: 0.84, size: 0.12 },
    { x: 0.101, y: 0.63, size: 0.12 },
    { x: 0.101, y: 0.37, size: 0.12 },
    { x: 0.253, y: 0.16, size: 0.12 },

    // Far Outer Ring (5 stars) - Corners & Side
    { x: 0.1, y: 0.1, size: 0.1 },
    { x: 0.9, y: 0.1, size: 0.1 },
    { x: 0.9, y: 0.9, size: 0.1 },
    { x: 0.1, y: 0.9, size: 0.1 },
    { x: 0.05, y: 0.5, size: 0.1 }
];

interface UserNode {
    username: string;
    pfpUrl: string;
    score?: number;
}

async function fetchImage(url: string): Promise<Buffer> {
    try {
        const response = await axios.get(url, { responseType: 'arraybuffer' });
        return Buffer.from(response.data);
    } catch (error) {
        console.error(`Failed to fetch image from ${url}`, error);
        // Return a placeholder or empty buffer on failure
        // For now, let's return a simple colored circle generated by sharp
        return await sharp({
            create: {
                width: 100,
                height: 100,
                channels: 4,
                background: { r: 100, g: 100, b: 100, alpha: 1 }
            }
        }).png().toBuffer();
    }
}

async function createCircularImage(imageBuffer: Buffer, size: number): Promise<Buffer> {
    const resized = await sharp(imageBuffer)
        .resize(size, size, { fit: 'cover' })
        .toBuffer();

    const circleMask = Buffer.from(
        `<svg><circle cx="${size / 2}" cy="${size / 2}" r="${size / 2}" /></svg>`
    );

    return await sharp(resized)
        .composite([{ input: circleMask, blend: 'dest-in' }])
        .png()
        .toBuffer();
}

export async function generateConstellationImage(
    centralUser: UserNode,
    interactions: UserNode[]
): Promise<Buffer> {
    const bgPath = path.join(process.cwd(), 'public', 'constellation-bg.jpg');
    const bgImage = sharp(bgPath);
    const metadata = await bgImage.metadata();

    const width = metadata.width || 1024;
    const height = metadata.height || 1024;

    const composites: sharp.OverlayOptions[] = [];

    // Combine central user and interactions
    // Ensure central user is always first and has a valid PFP or fallback
    const allUsers = [centralUser, ...interactions];

    // Limit to available star slots
    const usersToRender = allUsers.slice(0, STAR_COORDINATES.length);

    console.log(`Rendering ${usersToRender.length} users. Central: ${centralUser.username}`);

    for (let i = 0; i < usersToRender.length; i++) {
        const user = usersToRender[i];
        const coord = STAR_COORDINATES[i];

        // Calculate actual pixel position
        // The coordinates are for the CENTER of the star
        const size = Math.round(Math.min(width, height) * coord.size);
        const x = Math.round(width * coord.x) - Math.round(size / 2);
        const y = Math.round(height * coord.y) - Math.round(size / 2);

        // Fetch and process user PFP
        console.log(`Fetching PFP for ${user.username} at index ${i}`);
        let pfpBuffer: Buffer;
        try {
            pfpBuffer = await fetchImage(user.pfpUrl);
        } catch (e) {
            console.error(`Failed to fetch PFP for ${user.username}, using fallback.`);
            // Use a colorful fallback instead of gray
            pfpBuffer = await sharp({
                create: {
                    width: 100,
                    height: 100,
                    channels: 4,
                    background: { r: 100, g: 0, b: 255, alpha: 1 } // Purple fallback
                }
            }).png().toBuffer();
        }

        const circularPfp = await createCircularImage(pfpBuffer, size);

        composites.push({
            input: circularPfp,
            top: y,
            left: x,
        });
    }

    // Composite all images onto the background
    return await bgImage
        .composite(composites)
        .png()
        .toBuffer();
}
